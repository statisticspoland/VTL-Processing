== Basic Usage

=== .NET Core Dependency Injection

Usage of the Translator class, as shown in the Tutorial section, is just a simplified approach to use the library.
...

=== Modele danych

==== Deklaracja modeli danych

Modele danych deklaruje się poprzez dodanie reprezentacji interfejsu ``StatisticsPoland.VtlProcessing.Core.Models.Interfaces.IDataModel`` do agregatora modeli danych reprezentującego interfejs ``StatisticsPoland.VtlProcessing.Core.Infrastructure.InterfacesIDataModelAggregator``.

==== Domyślne modele danych

Przestrzeń nazw ``StatisticsPoland.VtlProcessing.Core.DataModelProviders.Models`` oferuje cztery domyślne typy modeli danych, które można w łatwy sposób dodać do reprezentacji interfejsu IDataModelAggregator dzięki dodatkowym metodom rozszerzającym ze statycznej klasy DataModelAggregatorExtension z przestrzeni nazw ``StatisticsPoland.VtlProcessing.Core.DataModelProviders``.

===== Model danych JSON

Model danych JSON wczytuje struktury danych z pliku o rozszerzeniu JSON o schemacie przedstawionym poniżej. Plik powinien zawierać obiekt "DataModel", w którym zawarte będą informacje takie jak nazwa przestrzeni nazw VTL oraz kolekcja struktur danych, zawierających nazwane kolekcje komponentów wraz z informacjami o ich nazwach i domenach wartości.

[source,json]
----
{
  "DataModel": {
    "Namespace": "",
    "DataStructuresCollection": [
      {
        "DatasetName": "",
        "Identifiers": [
          {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ],
        "Measures": [
          {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ],
        "ViralAttributes": [
            {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ],
        "NonViralAttributes": [
            {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ]
      }, ...
    ]
  }
}
----

===== Model danych wyrażeń regularnych

Model danych wyrażeń regularnych wczytuje struktury danych z podanego mu wcześniej słownika o kluczach nazw struktur oraz wartościach struktur danych.

[source,c#]
----
Dictionary<string, IDataStructure>
----

Pozwala to na tworzenie struktur danych z poziomu kodu. Nazwa przestrzeni nazw VTL jest nadawana w konstruktorze.

===== Model danych SQL Server

Model danych SQL Server wczytuje struktury danych na podstawie struktur tabel podanej bazy danych Transact SQL. Przestrzenie nazw danego modelu danych należy zadeklarować i zmapować w maperze przestrzeni nazw VTL.

Na podstawie typu danych kolumny TSQL dobierana jest odpowiadająca mu domena wartości komponentu VTL. Standardowy sposób dobierania przedstawiony został w tabeli poniżej.

[%header,cols=2*] 
|===
|Typy danych TSQL
|Domena wartości VTL

|TinyInt, SmallInt, Int, BigInt
|Integer

|Numeric, Decimal
|Number

|Bit
|Boolean

|Char, NChar, NText, NVarChar, NVarCharMax, Text, VarChar, VarCharMax
|String

|Date, DateTime, DateTime2, SmallDateTime, Time, Timestamp
|Date
|===

Tekstowe typy danych TSQL mogą być interpretowane jako czasowe domeny wartości VTL:

* "Date"
* "Time"
* "TimePeriod"
* "Duration". 

Można to uzyskać poprzez dodanie rozszerzonej wartości "vtl_time_type" dla odpowiedniej kolumny tabeli TSQL. Schemat dodania rozszerzonej wartości przedstawiono poniżej.

[source,sql]
----
EXEC sp_addextendedproperty   
	@name = N'vtl_time_type',   
	@value = '',  
	@level0type = N'Schema', @level0name = '',  
	@level1type = N'Table',  @level1name = '',  
	@level2type = N'Column', @level2name = '';  
GO
----

Nazwą rozszerznej wartości ma być "vtl_time_type". Jako wartość podajemy nazwę jednej z wyżej wymienionych czasowych domen wartości VTL. Wartości pola "level0name" należy przypisać nazwę schematu, do którego należy dana tabela. Wartość pola "level1name" odpowiada nazwie tabeli, natomiast "level2name" nazwie kolumny, dla której określamy czasową domenę wartości VTL.

Przy pomocy rozszerzonej wartości można okreslić dla kolumny tabeli TSQL [.underline]#typ komponentu VTL#, który ma reprezentować. Domyślnie kolumny oznaczone jako klucz główny są traktowane jako identyfikatory, a pozostałe jako miary, więc głównie stosuje się to do oznaczania atrybutów. 

W tym przypadku nazwą rozszerzonej wartości ma być "vtl_component_role", a wartością jedna z nazw typu komponentu VTL:

* "identifier"
* "measure"
* "attribute"
* "attribute.viral".

===== Model danych SDMX

Model danych SDMX wczytuje struktury danych z pliku struktury danych SDMX, a dokładnie z części Dataset Stucture Definition.

Na podstawie tekstowych typów danych SDMX dobierana jest odpowiadająca mu domena wartości komponentu VTL. Standardowy sposób dobierania przedstawiony został w tabeli poniżej.

[%header,cols=2*] 
|===
|Tekstowe typy danych SDMX
|Domena wartości VTL

|Null, AttachmentConstraintReference, DataSetReference, KeyValues, IdentifiableReference, Xhtml
|None

|Alpha, Alphanumeric, String, Time, Year, Month, Numeric, Day, MonthDay, YearMonth, Uri, Timespan
|String

|BasicTimePeriod, DateTime, Date, GregorianDay, GregorianTimePeriod, GregorianYear, GregorianYearMonth
|Date

|BigInteger, Integer, Long, Short, Count
|Integer

|Decimal, Float, Double, InclusiveValueRange, ExclusiveValueRange, Incremental
|Number

|Boolean
|Boolean

|Duration
|Duration

|ObservationalTimePeriod, StandardTimePeriod, TimesRange
|Time

|TimePeriod, ReportingDay, ReportingMonth, ReportingQuarter, ReportingSemester, ReportingTimePeriod, ReportingTrimester, ReportingWeek, ReportingYear
|TimePeriod

|===

Na podstawie elementów struktury danych SDMX dobierane są odpowiadające im elementy struktury VTL.  Standardowy sposób dobierania przedstawiony został w tabeli poniżej.

[%header,cols=2*] 
|===
|Element struktury SDMX
|Element struktury VTL

|Dimension
|Identifier

|PrimaryMeasure
|Measure

|Attribute
|Attribute

|===

==== Niestandardowe modele danych

Proces tworzenia niestandardowych modeli danych wraz z wymogami oraz wskazówkami znajduje się w kolejnej części dokumentu "04_custom_models".

=== Renderery języków docelowych

==== Deklaracja rendererów języków docelowych

Renderery języków docelowe deklaruje się poprzez wstrzyknięcie zależności reprezentacji interfejsu ``StatisticsPoland.VtlProcessing.Core.BackEnd.ITargetRenderer`` do kolekcji serwisów ``Microsoft.Extensions.DependencyInjection.ServiceCollection``. Można to zrobić bezpośrednio lub poprzez konfigurację obiektu klasy ``StatisticsPoland.VtlProcessing.Core.Translator``.

==== Standardowe renderery języków docelowych

Wyrózniamy dwa standardowe renderery języków docelowych, które wewnątrz swoich przestrzeni nazw ``nazwa_renderera.Infrastructure`` posiadają metody rozszerzające dla ``StatisticsPoland.VtlProcessing.Core.ITranslatorConfig`` oraz ``Microsoft.Extensions.DependencyInjection.IServiceCollection``, pozwalające na proste wstrzyknięcie renderera jako zależność projektu.

===== Renderer języka TSQL

Jest to renderer przetwarzający schematy reprezentacji pośredniej na kod wynikowy języka TSQL.

Podczas dodawania tego renderera do kolekcji serwisów są dostępne następujące metody konfiguracyjne:

* ``AddComments`` - wywołanie tej metody konfiguracyjnej dodaje komentarze do kodu wynikowego

* ``SetAttributePropagationAlgorithm`` - przy pomocy tej metody można zmienić algorytm propagacji atrybutów VTL w kodzie wynikowym poprzez podanie niestandardowej reprezentacji interfejsu ``StatisticsPoland.VtlProcessing.Target.TSQL.Infrastructure.Interfaces.IAttributePropagationAlgorithm`` (więcej w rozdziale "04_custom_models"). Standardowo używany jest algorytm działający według zasad opisanych w rozdziale "Behaviour for Attribute Components" dokumentu

> > SMDX Technical Working Group +
VTL Task Force +
VTL – version 2.0 +
(Validation & Transformation Language) +
Part 1 – User Manual

===== Renderer języka PlantUml

Jest to renderer przetwarzazjący schematy reprezentajci pośrenidej na kod wynikowy PlantUml w celu graficzengo przedstawienia schematu reprezentacji pośredniej.

Podczas dodawania tego renderera do kolekcji serwisów są dostępne następujące metody konfiguracyjne:

* ``UseHorizontalView`` - wywołanie tej metody konfiguracyjnej zmienia sposób graficznej prezentacji schematu transformacji pośredniej na horyzontalny. Domyślnie jest on prezentowany wertykalnie.

* ``AddDataStructureObject`` - wywołanie tej metody konfiguracyjnej dodaje do graficznej prezentacji schematu transformacji pośredniej dodatkowe obiekty opisujące struktury danych zawartych w nim wyrażeń.

* ``UseArrowFirstToLast`` - wywołanie tej metody konfiguracyjnej zmienia połączenia pomiędzy obiektami graficznej prezentacji schematu transformacji pośredniej na strzałki wskazujące według metody "od korzenia do liści". Domyślnie połączenia są zwyczajnymi liniami.

* ``UseArrowLastToFirst`` - wywołanie tej metody konfiguracyjnej zmienia połączenia pomiędzy obiektami graficznej prezentacji schematu transformacji pośredniej na strzałki wskazujące według metody "od liści do korzenia". Domyślnie połączenia są zwyczajnymi liniami.

* ``ShowNumberLine`` - wywołanie tej metody konfiguracyjnej dodaje do każdego wyrażenia graficznej prezentacji schematu transformacji pośredniej pole odpowiadające za numer linii, w którym znajduje się dane wyrażenie w kodzie źródłowym VTL.

* ``UseRuleExpressionsModel`` - wywołanie tej metody konfiguracyjnej zmienia tryb wyświetlania graficznej prezentacji schematu transformacji pośredniej ze zwykłych wyrażeń na wyrażenia zestawów zasad (rulesety).

==== Niestandardowe renderery języków docelowych

Proces tworzenia niestandardowych rendererów języków docelowych wraz z wymogami oraz wskazówkami znajduje się w kolejnej części dokumentu "04_custom_models".