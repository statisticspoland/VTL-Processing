== Basic Usage

=== .NET Core Dependency Injection

The Translator class, as shown in the Getting Started section, is just a simplified approach to use the library.
To utilize all the features of VtlProcessing and fully integrate it with your application, you should register it in .NET Core DI container.
This can be done simply by calling `AddVtlProcessing` method of your `IServiceCollection` object.

[source,c#]
----
services.AddVtlProcessing((configure) =>
  {
    // translator config goes here
  });
----

To get things working, it is necessary to setup some configuration options.

==== Provide Data Model

VtlProcessing translation engine, in order to perform type inference, need to be aware of a model of data.
You must to provide information about the structure of all input and output persistent data sets on witch your VTL expressions work.
It is possible to provide your own data model provider by implementing the `IDataModel` interface.
VtlProcessing provides several out of the box data model provider implementations.
It is also possible to combine different providers by using `IDataModelAggregator`.

===== JSON Data Model Provider

It allows to load dataset structure information from JSON file with the following schema:

[source,json]
----
{
  "DataModel": {
    "Namespace": "",
    "DataStructuresCollection": [
      {
        "DatasetName": "",
        "Identifiers": [
          {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ],
        "Measures": [
          {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ],
        "ViralAttributes": [
            {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ],
        "NonViralAttributes": [
            {
            "BaseComponentName": "",
            "ComponentName": "",
            "ValueDomain": {
              "Signature": ""
            }
          }, ...
        ]
      }, ...
    ]
  }
}
----

It is registered by using:

[source,c#]
----
configure.DataModels.AddJsonModel($"{Directory.GetCurrentDirectory()}\\your_file_name.json");
----

===== Dictionary Data Model Provider

It allows to programmatically fill data model metadata.
The default namespace name should be passed as a parameter.
The following example provides data model for dat sets `R1` and `R2` in namespace `def_ns`.

[source,c#]
----
configure.DataModels.AddDictionaryModel((config) =>
  {
    config
    .AddDataSet(
      "R1",
      (ComponentType.Identifier, BasicDataType.Integer, "Id1"),
      (ComponentType.Identifier, BasicDataType.Integer, "Id2"),
      (ComponentType.Measure, BasicDataType.Integer, "Me1"),
      (ComponentType.Measure, BasicDataType.Integer, "Me2"),
      (ComponentType.NonViralAttribute, BasicDataType.String, "At1"),
      (ComponentType.ViralAttribute, BasicDataType.Integer, "At2")
      )
    .AddDataSet(
      "R2",
      (ComponentType.Identifier, BasicDataType.Integer, "Id1"),
      (ComponentType.Measure, BasicDataType.String, "Me1"),
      (ComponentType.Measure, BasicDataType.Integer, "Me2")
      )
  }
  , "def_ns");
----

===== Model danych SQL Server

Model danych SQL Server wczytuje struktury danych na podstawie struktur tabel podanej bazy danych Transact SQL. Przestrzenie nazw danego modelu danych należy zadeklarować i zmapować w maperze przestrzeni nazw VTL.

Na podstawie typu danych kolumny TSQL dobierana jest odpowiadająca mu domena wartości komponentu VTL. Standardowy sposób dobierania przedstawiony został w tabeli poniżej.

[%header,cols=2*] 
|===
|Typy danych TSQL
|Domena wartości VTL

|TinyInt, SmallInt, Int, BigInt
|Integer

|Numeric, Decimal
|Number

|Bit
|Boolean

|Char, NChar, NText, NVarChar, NVarCharMax, Text, VarChar, VarCharMax
|String

|Date, DateTime, DateTime2, SmallDateTime, Time, Timestamp
|Date
|===

Tekstowe typy danych TSQL mogą być interpretowane jako czasowe domeny wartości VTL:

* "Date"
* "Time"
* "TimePeriod"
* "Duration". 

Można to uzyskać poprzez dodanie rozszerzonej wartości "vtl_time_type" dla odpowiedniej kolumny tabeli TSQL. Schemat dodania rozszerzonej wartości przedstawiono poniżej.

[source,sql]
----
EXEC sp_addextendedproperty   
	@name = N'vtl_time_type',   
	@value = '',  
	@level0type = N'Schema', @level0name = '',  
	@level1type = N'Table',  @level1name = '',  
	@level2type = N'Column', @level2name = '';  
GO
----

Nazwą rozszerznej wartości ma być "vtl_time_type". Jako wartość podajemy nazwę jednej z wyżej wymienionych czasowych domen wartości VTL. Wartości pola "level0name" należy przypisać nazwę schematu, do którego należy dana tabela. Wartość pola "level1name" odpowiada nazwie tabeli, natomiast "level2name" nazwie kolumny, dla której określamy czasową domenę wartości VTL.

Przy pomocy rozszerzonej wartości można okreslić dla kolumny tabeli TSQL [.underline]#typ komponentu VTL#, który ma reprezentować. Domyślnie kolumny oznaczone jako klucz główny są traktowane jako identyfikatory, a pozostałe jako miary, więc głównie stosuje się to do oznaczania atrybutów. 

W tym przypadku nazwą rozszerzonej wartości ma być "vtl_component_role", a wartością jedna z nazw typu komponentu VTL:

* "identifier"
* "measure"
* "attribute"
* "attribute.viral".

===== Model danych SDMX

Model danych SDMX wczytuje struktury danych z pliku struktury danych SDMX, a dokładnie z części Dataset Stucture Definition.

Na podstawie tekstowych typów danych SDMX dobierana jest odpowiadająca mu domena wartości komponentu VTL. Standardowy sposób dobierania przedstawiony został w tabeli poniżej.

[%header,cols=2*] 
|===
|Tekstowe typy danych SDMX
|Domena wartości VTL

|Null, AttachmentConstraintReference, DataSetReference, KeyValues, IdentifiableReference, Xhtml
|None

|Alpha, Alphanumeric, String, Time, Year, Month, Numeric, Day, MonthDay, YearMonth, Uri, Timespan
|String

|BasicTimePeriod, DateTime, Date, GregorianDay, GregorianTimePeriod, GregorianYear, GregorianYearMonth
|Date

|BigInteger, Integer, Long, Short, Count
|Integer

|Decimal, Float, Double, InclusiveValueRange, ExclusiveValueRange, Incremental
|Number

|Boolean
|Boolean

|Duration
|Duration

|ObservationalTimePeriod, StandardTimePeriod, TimesRange
|Time

|TimePeriod, ReportingDay, ReportingMonth, ReportingQuarter, ReportingSemester, ReportingTimePeriod, ReportingTrimester, ReportingWeek, ReportingYear
|TimePeriod

|===

Na podstawie elementów struktury danych SDMX dobierane są odpowiadające im elementy struktury VTL.  Standardowy sposób dobierania przedstawiony został w tabeli poniżej.

[%header,cols=2*] 
|===
|Element struktury SDMX
|Element struktury VTL

|Dimension
|Identifier

|PrimaryMeasure
|Measure

|Attribute
|Attribute

|===

==== Niestandardowe modele danych

Proces tworzenia niestandardowych modeli danych wraz z wymogami oraz wskazówkami znajduje się w kolejnej części dokumentu "04_custom_models".

=== Renderery języków docelowych

==== Deklaracja rendererów języków docelowych

Renderery języków docelowe deklaruje się poprzez wstrzyknięcie zależności reprezentacji interfejsu ``StatisticsPoland.VtlProcessing.Core.BackEnd.ITargetRenderer`` do kolekcji serwisów ``Microsoft.Extensions.DependencyInjection.ServiceCollection``. Można to zrobić bezpośrednio lub poprzez konfigurację obiektu klasy ``StatisticsPoland.VtlProcessing.Core.Translator``.

==== Standardowe renderery języków docelowych

Wyrózniamy dwa standardowe renderery języków docelowych, które wewnątrz swoich przestrzeni nazw ``nazwa_renderera.Infrastructure`` posiadają metody rozszerzające dla ``StatisticsPoland.VtlProcessing.Core.ITranslatorConfig`` oraz ``Microsoft.Extensions.DependencyInjection.IServiceCollection``, pozwalające na proste wstrzyknięcie renderera jako zależność projektu.

===== Renderer języka TSQL

Jest to renderer przetwarzający schematy reprezentacji pośredniej na kod wynikowy języka TSQL.

Podczas dodawania tego renderera do kolekcji serwisów są dostępne następujące metody konfiguracyjne:

* ``AddComments`` - wywołanie tej metody konfiguracyjnej dodaje komentarze do kodu wynikowego

* ``SetAttributePropagationAlgorithm`` - przy pomocy tej metody można zmienić algorytm propagacji atrybutów VTL w kodzie wynikowym poprzez podanie niestandardowej reprezentacji interfejsu ``StatisticsPoland.VtlProcessing.Target.TSQL.Infrastructure.Interfaces.IAttributePropagationAlgorithm`` (więcej w rozdziale "04_custom_models"). Standardowo używany jest algorytm działający według zasad opisanych w rozdziale "Behaviour for Attribute Components" dokumentu

> > SMDX Technical Working Group +
VTL Task Force +
VTL – version 2.0 +
(Validation & Transformation Language) +
Part 1 – User Manual

===== Renderer języka PlantUml

Jest to renderer przetwarzazjący schematy reprezentajci pośrenidej na kod wynikowy PlantUml w celu graficzengo przedstawienia schematu reprezentacji pośredniej.

Podczas dodawania tego renderera do kolekcji serwisów są dostępne następujące metody konfiguracyjne:

* ``UseHorizontalView`` - wywołanie tej metody konfiguracyjnej zmienia sposób graficznej prezentacji schematu transformacji pośredniej na horyzontalny. Domyślnie jest on prezentowany wertykalnie.

* ``AddDataStructureObject`` - wywołanie tej metody konfiguracyjnej dodaje do graficznej prezentacji schematu transformacji pośredniej dodatkowe obiekty opisujące struktury danych zawartych w nim wyrażeń.

* ``UseArrowFirstToLast`` - wywołanie tej metody konfiguracyjnej zmienia połączenia pomiędzy obiektami graficznej prezentacji schematu transformacji pośredniej na strzałki wskazujące według metody "od korzenia do liści". Domyślnie połączenia są zwyczajnymi liniami.

* ``UseArrowLastToFirst`` - wywołanie tej metody konfiguracyjnej zmienia połączenia pomiędzy obiektami graficznej prezentacji schematu transformacji pośredniej na strzałki wskazujące według metody "od liści do korzenia". Domyślnie połączenia są zwyczajnymi liniami.

* ``ShowNumberLine`` - wywołanie tej metody konfiguracyjnej dodaje do każdego wyrażenia graficznej prezentacji schematu transformacji pośredniej pole odpowiadające za numer linii, w którym znajduje się dane wyrażenie w kodzie źródłowym VTL.

* ``UseRuleExpressionsModel`` - wywołanie tej metody konfiguracyjnej zmienia tryb wyświetlania graficznej prezentacji schematu transformacji pośredniej ze zwykłych wyrażeń na wyrażenia zestawów zasad (rulesety).

==== Niestandardowe renderery języków docelowych

Proces tworzenia niestandardowych rendererów języków docelowych wraz z wymogami oraz wskazówkami znajduje się w kolejnej części dokumentu "04_custom_models".