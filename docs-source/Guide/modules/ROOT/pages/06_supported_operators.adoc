:icons: font

== Supported Operators

W poniższej tabeli została przedstawiona lista wszystkich operatorów VTL 2.0 wraz ze statusem ich zaimplementowania w translatorze. 

Obsługa VtlProcessing.Core oznacza, że podczas użycia operatora w kodzie źródłowym zostanie on rozpoznany przez translator i obsłużony w schemacie transformacji pośredniej.

Obsługa VtlProcessing.Target.TSQL oznacza, że przy użyciu operatora translator będzie w stanie wygenerować kod wynikowy TSQL. 

[cols=4*, options="header"]
|===
|Nazwa operatora
|Symbol(e) operatora
|Obsługa VtlProcessing.Core
|Obsługa VtlProcessing.Target.TSQL

|Parentheses
|()
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Persistent assignment
|$$<-$$
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Non-persistent assignment
|:=
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Membership
|#
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|User-definied operator call
|
|[red]#icon:times[]#
|[red]#icon:times[]#

|Evaluation of an external routine
|eval
|[red]#icon:times[]#
|[red]#icon:times[]#

|Type conversion
|cast
|[red]#icon:times[]#
|[red]#icon:times[]#

|Join
|inner_join, left_join, full_join, cross_join
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|String concatenation
|$$\|\|$$
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Whitespace removal
|trim, rtrim, ltrim
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Character case conversion
|upper/lower
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Sub-string extraction
|substr
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|String pattern replacement
|replace
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|String pattern location
|instr
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|String length
|length
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Unary plus
|+
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Unary minus
|-
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Addition
|+
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Substraction
|-
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Multiplication
|*
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Division
|/
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Modulo
|mod
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Rounding
|round
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Truncation
|trunc
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Ceiling
|ceil
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Floor
|floor
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Absolute value
|abs
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Exponential
|exp
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Natural logarithm
|ln
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Power
|power
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Logarithm
|log
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Square root
|sqrt
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Equal to
|=
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Not equal to
|<>
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Greater than
|> >=
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Less than
|< $$<=$$
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Between
|between
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Element of
|in/not_in
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|match_characters
|match_characters
|[lime]#icon:check[]#
|[red]#icon:times[]#

|isnull
|isnull
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Exists in
|exists_in
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Logical conjunction
|and
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Logical disjunction
|or
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Exclusive disjunction
|xor
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Logical negation
|not
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Period indicator
|period_indicator
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Fill time series
|fill_time_series
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Flow to stock
|flow_to_stock
|[lime]#icon:check[]#
|[lime]#icon:check[]#
|Stock to flow
|stock_to_flow
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Time shift
|timeshift
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Time aggregation
|time_agg
|[red]#icon:times[]#
|[red]#icon:times[]#

|Actual time
|current_date
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Union
|union
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Intersection
|intersect
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Set difference
|setdiff
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Simmetric difference
|symdiff
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Hierarchical roll-up
|hierarchy
|[red]#icon:times[]#
|[red]#icon:times[]#

|Aggregate invocation
|
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Analytic invocation
|
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Counting the number of data points
|count
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Minimum value
|min
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Maximum value
|max
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Median value
|median
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Sum
|sum
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Average value
|avg
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Population standard deviation
|stddev_pop
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Sample standard deviation
|stddev_samp
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Population variance
|var_pop
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Sample variance
|var_samp
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|First value
|first_value
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Last value
|last_value
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Lag
|lag
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Lead
|lead
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Rank
|rank
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Ratio to report
|ratio_to_report
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|check_datapoint
|check_datapoint
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|check_hierarchy
|check_hierarchy
|[red]#icon:times[]#
|[red]#icon:times[]#

|check
|check
|[red]#icon:times[]#
|[red]#icon:times[]#

|if-then-else
|if
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Nvl
|nvl
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Filtering Data Points
|filter
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Calculation of a Component
|calc
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Aggregation
|aggr
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Maintaining Components
|keep
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Removal of Components
|drop
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Change of Component name
|rename
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|Pivoting
|pivot
|[lime]#icon:check[]#
|[red]#icon:times[]#

|Unpivoting
|unpivot
|[lime]#icon:check[]#
|[red]#icon:times[]#

|Subspace
|sub
|[lime]#icon:check[]#
|[lime]#icon:check[]#

|===

=== Obsługa czasowych domen wartości VTL

==== Obsługiwane maski czasowych domen wartości VTL

Poprawna obsługa czasowych domen wartości VTL przez translator VTL jest ograniczona do masek podanych w tabeli poniżej. Wprowadzając czasową wartość w kodzie VTL oraz przechowując dane o czasowej domenie wartości należy przestrzegać danych masek, w przeciwnym razie wynik działania translatora na danych wartościach będzie nieprawidłowy.

[%header,cols=2*] 
|===
|Czasowa domena wartości
|Obsługiwane maski

|Date
|"yyyy-mm-dd", +
"yyyy-mm"

|Time
|"yyyy-mm-dd/yyyy-mm-dd", +
"yyyy-mm/yyyy-mm"

|TimePeriod
|"yyyy", +
"yyyyA" +
"yyyyS{s}" +
"yyyyQ{q}" +
"yyyyM{mm}" +
"yyyyW{ww}" +
"yyyyD{ddd}" +

|Duration
|"A", "S", "Q", "M", "W", "D"
|===

==== Uproszczone użycie typów czasowych

Zagłębiając się w przykłady z dokumentu

> > SMDX Technical Working Group +
VTL Task Force +
VTL – version 2.0 +
(Validation & Transformation Language) +
Part 2 – Reference Manual

można dojść do wniosku, że do użycia skalarnego wyrażenia czasowego, należy przy użyciu operatora konwersji typów (CAST) przekonwertować skalarne wyrażenie typu string na oczekiwany typ czasowy.

.Przykład użycia operatora CAST do uzyskania skalarnych wyrażeń czasowych
[source]
----
cast("2000Q1", time_period, "YYYY\QQ")
cast("20120213", date, "YYYYMMDD")
----

W celu uproszczenia zapytań VTL translator posiada funkcjonalność rozpoznawania czasowych wyrażeń skalarnych. Należy je podawać w postaci wyrażenia reprezentującego ciąg znaków poprzedzonego literą "t".

.Przykład uproszczonego uzyskania skalarnych wyrażeń czasowych za pomocą przedrostka "t"
[source]
----
t"2000Q1"
t"2012-02-13"
----

WARNING: Funkcjonalność działa poprawnie tylko dla masek z powyższej tabeli.

NOTE: Documentation under construction